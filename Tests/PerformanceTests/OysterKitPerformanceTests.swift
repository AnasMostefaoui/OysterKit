//
//  OysterKitPerformanceTests.swift
//  OysterKitPerformanceTests
//
//  
//  Copyright Â© 2016 RED When Excited. All rights reserved.
//

import XCTest
import OysterKit
import STLR
import ExampleLanguages

class OysterKitPerformanceTests: XCTestCase {
    
    let swiftSource = "// \n// STLR Generated Swift File \n// \n// Generated: 2016-08-19 10:45:49 +0000\n// \nimport OysterKit\n\n// \n// FullSwiftParser Parser\n// \nclass FullSwiftParser : Parser{\n\n\t// Convenience alias\n\tprivate typealias GrammarToken = Tokens\n\n\t// Token & Rules Definition\n\tenum Tokens : Int, Token {\n\t\tcase _transient, comment, ws, eol, access, scope, number, key, entry, dictionary, dictionary, array, string, variable, inherit, parameter, parameters, index, import, class, alias, enum, case, caseBlock, func, switch, return, reference, var, call, guard, assignment, block, statement, swift\n\n\t\tfunc _rule(_ annotations: RuleAnnotations = [ : ])->Rule {\n\t\t\tswitch self {\n\t\t\tcase ._transient:\n\t\t\t\treturn CharacterSet(charactersIn: \"\").terminal(token: GrammarToken._transient)\n\t\t\t// comment\n\t\t\tcase .comment:\n\t\t\t\treturn [\n\t\t\t\t\t\"//\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.newlines.terminal(token: GrammarToken._transient).not(producing: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.comment)\n\t\t\t// ws\n\t\t\tcase .ws:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.comment._rule(),\n\t\t\t\t\tCharacterSet.whitespacesAndNewlines.terminal(token: GrammarToken._transient),\n\t\t\t\t\t].oneOf(token: GrammarToken.ws)\n\t\t\t// eol\n\t\t\tcase .eol:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.comment._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.newlines.terminal(token: GrammarToken._transient).not(producing: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.newlines.terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.eol)\n\t\t\t// access\n\t\t\tcase .access:\n\t\t\t\treturn ScannerRule.oneOf(token: GrammarToken.access, [\"static\", \"private\", \"fileprivate\", \"open\", \"internal\", \"public\"])\n\t\t\t// scope\n\t\t\tcase .scope:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.access._rule(),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.access._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.scope)\n\t\t\t// number\n\t\t\tcase .number:\n\t\t\t\treturn CharacterSet.decimalDigits.terminal(token: GrammarToken._transient).repeated(min: 1, producing: GrammarToken.number)\n\t\t\t// key\n\t\t\tcase .key:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.string._rule(),\n\t\t\t\t\tGrammarToken.number._rule(),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t].oneOf(token: GrammarToken.key)\n\t\t\t// entry\n\t\t\tcase .entry:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\t\t\tGrammarToken.key._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\tGrammarToken.reference._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t].sequence(token: GrammarToken.entry)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// dictionary\n\t\t\tcase .dictionary:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t].oneOf(token: GrammarToken.dictionary)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// dictionary\n\t\t\tcase .dictionary:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t].oneOf(token: GrammarToken.dictionary)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// array\n\t\t\tcase .array:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.array)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// string\n\t\t\tcase .string:\n\t\t\t\treturn [\n\t\t\t\t\t\"\\\"\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"\\\\\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tCharacterSet(charactersIn: \"\\\"\\\\\").terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"\\\"\".terminal(token: GrammarToken._transient).not(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"\\\"\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.string)\n\t\t\t// variable\n\t\t\tcase .variable:\n\t\t\t\treturn [\n\t\t\t\t\tCharacterSet.letters.union(CharacterSet(charactersIn: \"_\")).terminal(token: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.letters.union(CharacterSet.decimalDigits).union(CharacterSet(charactersIn: \"_\")).terminal(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.variable)\n\t\t\t// inherit\n\t\t\tcase .inherit:\n\t\t\t\treturn [\n\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.inherit)\n\t\t\t// parameter\n\t\t\tcase .parameter:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"_\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.dictionary._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.parameter)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// parameters\n\t\t\tcase .parameters:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"(\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.parameter._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.parameter._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\")\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.parameters)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// index\n\t\t\tcase .index:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.index)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// import\n\t\t\tcase .import:\n\t\t\t\treturn [\n\t\t\t\t\t\"import\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.eol._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.import)\n\t\t\t// class\n\t\t\tcase .class:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\tGrammarToken.scope._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"class\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.inherit._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.class)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// alias\n\t\t\tcase .alias:\n\t\t\t\treturn [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.scope._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"typealias\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.eol._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.alias)\n\t\t\t// enum\n\t\t\tcase .enum:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.scope._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"enum\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.inherit._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.enum)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// case\n\t\t\tcase .case:\n\t\t\t\treturn [\n\t\t\t\t\t\"case\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.case)\n\t\t\t// caseBlock\n\t\t\tcase .caseBlock:\n\t\t\t\treturn [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"case\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"default\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.caseBlock)\n\t\t\t// func\n\t\t\tcase .func:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\tGrammarToken.scope._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"func\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"init\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.parameters._rule(),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"->\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\"?\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.func)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// switch\n\t\t\tcase .switch:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"switch\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.switch)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// return\n\t\t\tcase .return:\n\t\t\t\treturn [\n\t\t\t\t\t\"return\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.return)\n\t\t\t// reference\n\t\t\tcase .reference:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.call._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.index._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.string._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.array._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.number._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.dictionary._rule(),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"!\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.reference)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// var\n\t\t\tcase .var:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.scope._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tScannerRule.oneOf(token: GrammarToken._transient, [\"var\", \"let\"]),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"?\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.block._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.var)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// call\n\t\t\tcase .call:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"#\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.parameters._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.call)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// guard\n\t\t\tcase .guard:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"guard\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.var._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"else\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.guard)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// assignment\n\t\t\tcase .assignment:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.assignment)\n\t\t\t// block\n\t\t\tcase .block:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"{\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.statement._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"}\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.block)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// statement\n\t\t\tcase .statement:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\tGrammarToken.import._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.class._rule(),\n\t\t\t\t\tGrammarToken.enum._rule(),\n\t\t\t\t\tGrammarToken.var._rule(),\n\t\t\t\t\tGrammarToken.case._rule(),\n\t\t\t\t\tGrammarToken.caseBlock._rule(),\n\t\t\t\t\tGrammarToken.func._rule(),\n\t\t\t\t\tGrammarToken.switch._rule(),\n\t\t\t\t\tGrammarToken.return._rule(),\n\t\t\t\t\tGrammarToken.alias._rule(),\n\t\t\t\t\tGrammarToken.call._rule(),\n\t\t\t\t\tGrammarToken.guard._rule(),\n\t\t\t\t\tGrammarToken.assignment._rule(),\n\t\t\t\t\t].oneOf(token: GrammarToken.statement)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// swift\n\t\t\tcase .swift:\n\t\t\t\treturn [\n\t\t\t\t\t\t\t\tGrammarToken.ws._rule(),\n\t\t\t\t\t\t\t\tGrammarToken.statement._rule(),\n\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken.swift)\n\t\t\t}\n\t\t}\n\n\t\t// Color Definitions\n\t\tfileprivate var color : NSColor? {\n\t\t\tswitch self {\n\t\t\tcase .comment:\treturn #colorLiteral(red:0.11457, green:0.506016, blue:0.128891, alpha: 1)\n\t\t\tcase .scope:\treturn #colorLiteral(red:0.207304, green:0.362127, blue:0.401488, alpha: 1)\n\t\t\tcase .number:\treturn #colorLiteral(red:0.0, green:0.589801, blue:1.0, alpha: 1)\n\t\t\tcase .string:\treturn #colorLiteral(red:0.815686, green:0.129412, blue:0.12549, alpha: 1)\n\t\t\tcase .variable:\treturn #colorLiteral(red:0.309804, green:0.541176, blue:0.6, alpha: 1)\n\t\t\tdefault:\treturn nil\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Color Dictionary\n\tstatic var colors = [\"comment\" : GrammarToken.comment.color!, \"scope\" : GrammarToken.scope.color!, \"number\" : GrammarToken.number.color!, \"string\" : GrammarToken.string.color!, \"variable\" : GrammarToken.variable.color!]\n\n\t// Cache for left-hand recursive rules\n\tprivate static var leftHandRecursiveRules = [ Int : Rule ]()\n\n\t// Initialize the parser with the base rule set\n\tinit(){\n\t\tsuper.init(grammar: [GrammarToken.swift._rule()])\n\t}\n}\n"
    
    let stlrSource = "/************************************************************ \n\n\t\t\tSwift Tool for Language Recognition (STLR)  \n\nSTLR can be fully described itself, and this example is \nprovided to both provide  a formal document capturing STLR \nand to illustrate a complex use of the format.\n\nChange log: \n\tv0.0.0\t8  Aug 2016 \tInitial version \n\tv0.0.1\t15 Aug 2016\t\tAdded annotations changed to \n\t\t\t\t\t\t\tremove semi-colons and use \n\t\t\t\t\t\t\t\" not \'\n\tv0.0.2\t16 Aug 2016\t\tAdded look ahead    \n\tv0.0.3\t17 Aug 2016\t\tAdded errors to grammar \n\tv0.0.4\t18 Aug 2016\t\tChanged the format of annotations \n\t\t\t\t\t\t\tto be more Swift like \n\tv0.0.5\t22 Aug 2016 \tAdded support for nested multiline \n\t\t\t\t\t\t\tcomments\n\tv0.0.6 \t24 Aug 2016\t\tChanged position of negation\n\t\t\t\t\t\t\toperator to better match Swift and\n\t\t\t\t\t\t\tadded more error information.\n\tv0.0.7  10 Sep 2017\t\tAdded module importing\n\n*************************************************************/\n\n//\n// Whitespace\n// \nsingleLineComment\t\t= \"//\" !.newlines* .newlines\nmultilineComment\t\t= \"/*\" (multilineComment | !\"*/\")* \"*/\"\ncomment\t\t\t\t\t= singleLineComment | multilineComment\n@void\nwhitespace\t \t\t\t= comment | .whitespacesAndNewlines\nows\t\t\t\t\t\t= whitespace*\n\n//\n// Constants  \n//\n//definition\t\t\t= \"const\"\tows identifier ows \"=\" ows literal .whitespaces* whitespace\n\n//\n// Quantifiers, does this still work?\n//\nquantifier\t\t\t\t= \"*\" | \"+\" | \"?\" | \"-\" \nnegated\t\t\t\t\t= \"!\"\ntransient\t\t\t\t= \"-\"\n\n//\n// Parsing Control \n//\nlookahead\t\t\t\t= \">>\"\n\n//\n// String \n//\nstringQuote\t\t\t\t= \"\\\"\"\nescapedCharacters \t\t= stringQuote | \"r\" | \"n\" | \"t\" | \"\\\\\"\nescapedCharacter \t\t= \"\\\\\" escapedCharacters\n@void\nstringCharacter \t\t= escapedCharacter | !(stringQuote | .newlines)\nterminalBody\t\t\t= stringCharacter+\nstringBody\t\t\t\t= stringCharacter*\nstring\t\t\t\t\t= stringQuote \n\t\t\t\t\t\t\tstringBody \n\t\t\t\t\t\t  @error(\"Missing terminating quote\")\n\t\t\t\t\t\t  stringQuote\nterminalString\t\t\t= stringQuote \n\t\t\t\t\t\t  \t@error(\"Terminals must have at least one character\") \n\t\t\t\t\t\t\tterminalBody \n\t\t\t\t\t\t  @error(\"Missing terminating quote\")\n\t\t\t\t\t\t  stringQuote\n\n//\n// Character Sets and Ranges \n//\ncharacterSetName\t\t= \"letters\" | \n\t\t\t\t\t\t  \"uppercaseLetters\" | \n\t\t\t\t\t\t  \"lowercaseLetters\" | \n\t\t\t\t\t\t  \"alphaNumerics\" | \n\t\t\t\t\t\t  \"decimalDigits\" | \n\t\t\t\t\t\t  \"whitespacesAndNewlines\" | \n\t\t\t\t\t\t  \"whitespaces\" | \n\t\t\t\t\t\t  \"newlines\"\ncharacterSet\t\t\t= (\".\" @error(\"Unknown character set\") characterSetName)\n\nrangeOperator\t\t\t= \".\" @error(\"Expected ... in character range\") \"..\"\ncharacterRange\t\t\t= terminalString rangeOperator @error(\"Range must be terminated\") terminalString\n\n//\n// Types\n//\nnumber \t\t\t\t\t= (\"-\" | \"+\")? .decimalDigits+\nboolean \t\t\t\t= \"true\" | \"false\"\nliteral\t\t\t\t\t= string | number | boolean\n\n//\n// Annotations  \n//\nannotation  \t\t\t= \"@\" \n\t\t\t\t\t\t\t@error(\"Expected an annotation label\") label ( \n\t\t\t\t\t\t\t\t\"(\" \n\t\t\t\t\t\t\t\t@error(\"A value must be specified or the () omitted\") \n\t\t\t\t\t\t\t\tliteral \n\t\t\t\t\t\t\t\t@error(\"Missing \')\'\") \n\t\t\t\t\t\t\t\t\")\" \n\t\t\t\t\t\t\t)?\nannotations \t\t\t= (annotation ows)+\n\ncustomLabel  \t\t\t= @error(\"Labels must start with a letter or _\") (.letters | \"_\") ( .letters | .decimalDigits | \"_\" )*\ndefinedLabel \t\t\t= \"token\" | \"error\" | \"void\" | \"transient\"\nlabel \t\t\t\t\t= definedLabel | customLabel\n\n//\n// Element\n//\nterminal \t\t\t\t= characterSet | characterRange | terminalString \ngroup\t\t\t\t\t= \"(\" whitespace* \n\t\t\t\t\t\t\texpression whitespace* \n\t\t\t\t\t\t\t@error(\"Expected \')\'\") \n\t\t\t\t\t\t   \")\" \nidentifier \t\t\t\t= (.letters | \"_\") ( .letters | .decimalDigits | \"_\" )*  \n\nelement \t\t\t\t= annotations? (lookahead | transient)? negated? ( group | terminal | identifier ) quantifier? \n\n//\n// Expressions\n//\nassignmentOperators\t\t= \"=\" | \"+=\" | \"|=\"\n@void\nor \t\t\t\t\t\t=  whitespace* \"|\" whitespace*\n@void\nthen \t\t\t\t\t= (whitespace* \"+\" whitespace*) | whitespace+\n\nchoice\t\t\t\t\t= element (or @error(\"Expected terminal, identifier, or group\") element)+\nnotNewRule\t\t\t\t= !(annotations? identifier whitespace* assignmentOperators)\nsequence\t\t\t\t= element (then >>notNewRule @error(\"Expected terminal, identifier, or group\")element)+ \n\nexpression \t\t\t\t= choice | sequence | element\n\n//\n// Rule \n//\n@transient\nlhs\t\t\t\t\t\t= whitespace* annotations? transient? identifier whitespace* assignmentOperators\nrule \t\t\t\t\t= lhs whitespace* @error(\"Expected expression\")expression whitespace*\n\n//\n// Importing\n//\nmoduleName\t\t\t\t= (.letters | \"_\") (.letters | \"_\" | .decimalDigits)*\nmoduleImport\t\t\t= whitespace* @token(\"import\") \"import\" .whitespaces+  moduleName whitespace+\n\n// \n// Grammar\n//\n\ngrammar\t\t\t \t\t= @token(\"mark\") >>(!\" \"|\" \") moduleImport* @error(\"Expected at least one rule\") rule+ //NB: Mark is there to ensure there is no automatic reduction of rule into grammar if there is only one rule, this should perhaps become an annotation\n"
    
    override func setUp() {
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        super.tearDown()
    }
    
    func testPerformanceOfScanString() {
        let sourceLength = 200000
        
        var source = ""
        
        for _ in 0..<sourceLength {
            source += "Hello world"
        }
        
        var scanCount = 0
        
        // This is an example of a performance test case.
        self.measure {
            let lexer = Lexer(source: source)
            scanCount = 0
            do {
                while scanCount < sourceLength{
                    try lexer.scan(terminal: "Hello world")
                    scanCount += 1
                }
                
                
                XCTAssert(lexer.endOfInput, "Expected to be at end of input")
            } catch {
                XCTFail("Scan should not throw \(scanCount)")
            }
        }
    }
    
    
    func testPerformanceOfScanCharacterInSet() {
        let sourceLength = 1500000
        let source = String(repeating: "a", count: sourceLength)
        
        let characterSet = CharacterSet(charactersIn: "a")
        var scanCount = 0
        
        // This is an example of a performance test case.
        self.measure {
            let lexer = Lexer(source: source)
            scanCount = 0
            do {
                while scanCount < sourceLength{
                    try lexer.scan(oneOf: characterSet)
                    scanCount += 1
                }
                
                
                XCTAssert(lexer.endOfInput, "Expected to be at end of input")
            } catch {
                XCTFail("Scan should not throw \(scanCount)")
            }
        }
    }

    func testPerformanceSTLR() {
        
        let _ = STLRParser(source: stlrSource)
        
        // This is an example of a performance test case.
        self.measure {
            let stlr = STLRParser(source: self.stlrSource)
            
            let ruleCount = stlr.ast.rules.count
            XCTAssert(ruleCount == 47,"Got \(ruleCount) rules")
            
            do {
                try stlr.ast.validate()
            } catch (let error){
                XCTFail("Did not validate \(error)")
            }
        }
    }
    
    func testSwiftParserPerformance(){
        final class NullIR : IntermediateRepresentation{
            fileprivate func willBuildFrom(source: String, with: Language) {
                
            }
            
            fileprivate func didBuild() {
                
            }
            
            fileprivate func didEvaluate(rule: Rule, matchResult: MatchResult) {
                
            }
            
            fileprivate func willEvaluate(rule: Rule, at position: String.UnicodeScalarView.Index) -> MatchResult? {
                return nil
            }
            
            func resetState() {
                
            }
        }
        
        let parser = SwiftParser()
        let _ = parser.build(source: swiftSource) as NullIR
        
        // This is an example of a performance test case.
        self.measure {
            let _ = parser.build(source: self.swiftSource) as NullIR
        }
        
    }
    
    func testPerformanceSTLRParseOnly() {
        final class NullIR : IntermediateRepresentation{
            fileprivate func willBuildFrom(source: String, with: Language) {
                
            }
            
            fileprivate func didBuild() {
                
            }
            
            fileprivate func didEvaluate(rule: Rule, matchResult: MatchResult) {
                
            }
            
            fileprivate func willEvaluate(rule: Rule, at position: String.UnicodeScalarView.Index) -> MatchResult? {
                return nil
            }
            
            func resetState() {
                
            }
        }
        
        let parser = STLRParser(source: stlrSource)
        
        // This is an example of a performance test case.
        self.measure {
            do {
                let result = try parser.grammar[0].match(with: Lexer(source:self.stlrSource), for: NullIR())
                if case .success = result {
                    
                } else {
                    XCTFail("Failed to parse")
                }
            } catch (let error){
                XCTFail("Unexpected failure \(error)")
            }
        }
    }
}
