//
//  OysterKitPerformanceTests.swift
//  OysterKitPerformanceTests
//
//  
//  Copyright Â© 2016 RED When Excited. All rights reserved.
//

import XCTest
import OysterKit
import ExampleLanguages

class OysterKitPerformanceTests: XCTestCase {
    
    let swiftSource = "// \n// STLR Generated Swift File \n// \n// Generated: 2016-08-19 10:45:49 +0000\n// \nimport OysterKit\n\n// \n// FullSwiftParser Parser\n// \nclass FullSwiftParser : Parser{\n\n\t// Convenience alias\n\tprivate typealias GrammarToken = Tokens\n\n\t// Token & Rules Definition\n\tenum Tokens : Int, Token {\n\t\tcase _transient, comment, ws, eol, access, scope, number, key, entry, dictionary, dictionary, array, string, variable, inherit, parameter, parameters, index, import, class, alias, enum, case, caseBlock, func, switch, return, reference, var, call, guard, assignment, block, statement, swift\n\n\t\tfunc _rule(_ annotations: RuleAnnotations = [ : ])->Rule {\n\t\t\tswitch self {\n\t\t\tcase ._transient:\n\t\t\t\treturn CharacterSet(charactersIn: \"\").terminal(token: GrammarToken._transient)\n\t\t\t// comment\n\t\t\tcase .comment:\n\t\t\t\treturn [\n\t\t\t\t\t\"//\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.newlines.terminal(token: GrammarToken._transient).not(producing: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.comment)\n\t\t\t// ws\n\t\t\tcase .ws:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.comment._rule(),\n\t\t\t\t\tCharacterSet.whitespacesAndNewlines.terminal(token: GrammarToken._transient),\n\t\t\t\t\t].oneOf(token: GrammarToken.ws)\n\t\t\t// eol\n\t\t\tcase .eol:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.comment._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.newlines.terminal(token: GrammarToken._transient).not(producing: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.newlines.terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.eol)\n\t\t\t// access\n\t\t\tcase .access:\n\t\t\t\treturn ScannerRule.oneOf(token: GrammarToken.access, [\"static\", \"private\", \"fileprivate\", \"open\", \"internal\", \"public\"])\n\t\t\t// scope\n\t\t\tcase .scope:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.access._rule(),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.access._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.scope)\n\t\t\t// number\n\t\t\tcase .number:\n\t\t\t\treturn CharacterSet.decimalDigits.terminal(token: GrammarToken._transient).repeated(min: 1, producing: GrammarToken.number)\n\t\t\t// key\n\t\t\tcase .key:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.string._rule(),\n\t\t\t\t\tGrammarToken.number._rule(),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t].oneOf(token: GrammarToken.key)\n\t\t\t// entry\n\t\t\tcase .entry:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\t\t\tGrammarToken.key._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\tGrammarToken.reference._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t].sequence(token: GrammarToken.entry)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// dictionary\n\t\t\tcase .dictionary:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t].oneOf(token: GrammarToken.dictionary)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// dictionary\n\t\t\tcase .dictionary:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.entry._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t].oneOf(token: GrammarToken.dictionary)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// array\n\t\t\tcase .array:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.array)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// string\n\t\t\tcase .string:\n\t\t\t\treturn [\n\t\t\t\t\t\"\\\"\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"\\\\\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tCharacterSet(charactersIn: \"\\\"\\\\\").terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"\\\"\".terminal(token: GrammarToken._transient).not(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"\\\"\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.string)\n\t\t\t// variable\n\t\t\tcase .variable:\n\t\t\t\treturn [\n\t\t\t\t\tCharacterSet.letters.union(CharacterSet(charactersIn: \"_\")).terminal(token: GrammarToken._transient),\n\t\t\t\t\tCharacterSet.letters.union(CharacterSet.decimalDigits).union(CharacterSet(charactersIn: \"_\")).terminal(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.variable)\n\t\t\t// inherit\n\t\t\tcase .inherit:\n\t\t\t\treturn [\n\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.inherit)\n\t\t\t// parameter\n\t\t\tcase .parameter:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"_\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.dictionary._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.parameter)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// parameters\n\t\t\tcase .parameters:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"(\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.parameter._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.parameter._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\")\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.parameters)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// index\n\t\t\tcase .index:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"[\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\"]\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.index)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// import\n\t\t\tcase .import:\n\t\t\t\treturn [\n\t\t\t\t\t\"import\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.eol._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.import)\n\t\t\t// class\n\t\t\tcase .class:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\tGrammarToken.scope._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"class\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.inherit._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.class)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// alias\n\t\t\tcase .alias:\n\t\t\t\treturn [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.scope._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"typealias\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.eol._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.alias)\n\t\t\t// enum\n\t\t\tcase .enum:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.scope._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"enum\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.inherit._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.enum)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// case\n\t\t\tcase .case:\n\t\t\t\treturn [\n\t\t\t\t\t\"case\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.case)\n\t\t\t// caseBlock\n\t\t\tcase .caseBlock:\n\t\t\t\treturn [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"case\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\",\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"default\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.caseBlock)\n\t\t\t// func\n\t\t\tcase .func:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\tGrammarToken.scope._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"func\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\"init\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.parameters._rule(),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"->\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\"?\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.func)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// switch\n\t\t\tcase .switch:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"switch\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.switch)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// return\n\t\t\tcase .return:\n\t\t\t\treturn [\n\t\t\t\t\t\"return\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.return)\n\t\t\t// reference\n\t\t\tcase .reference:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.call._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.index._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.string._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.array._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.number._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.dictionary._rule(),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\"!\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.reference)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// var\n\t\t\tcase .var:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tGrammarToken.scope._rule(),\n\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tScannerRule.oneOf(token: GrammarToken._transient, [\"var\", \"let\"]),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\":\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"?\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.block._rule().optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.var)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// call\n\t\t\tcase .call:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\"#\".terminal(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\".\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGrammarToken.variable._rule(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\t\t\t\t].sequence(token: GrammarToken._transient).optional(producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.parameters._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.call)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// guard\n\t\t\tcase .guard:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"guard\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.var._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"else\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.block._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.guard)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// assignment\n\t\t\tcase .assignment:\n\t\t\t\treturn [\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"=\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.reference._rule(),\n\t\t\t\t\t].sequence(token: GrammarToken.assignment)\n\t\t\t// block\n\t\t\tcase .block:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\t\"{\".terminal(token: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.statement._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 0, producing: GrammarToken._transient),\n\t\t\t\t\t\"}\".terminal(token: GrammarToken._transient),\n\t\t\t\t\t].sequence(token: GrammarToken.block)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// statement\n\t\t\tcase .statement:\n\t\t\t\tguard let cachedRule = FullSwiftParser.leftHandRecursiveRules[self.rawValue] else {\n\t\t\t\t\t// Create recursive shell\n\t\t\t\t\tlet recursiveRule = RecursiveRule()\n\t\t\t\t\tFullSwiftParser.leftHandRecursiveRules[self.rawValue] = recursiveRule\n\t\t\t\t\t// Create the rule we would normally generate\n\t\t\t\t\tlet rule = [\n\t\t\t\t\tGrammarToken.import._rule(),\n\t\t\t\t\tGrammarToken.ws._rule().repeated(min: 1, producing: GrammarToken._transient),\n\t\t\t\t\tGrammarToken.class._rule(),\n\t\t\t\t\tGrammarToken.enum._rule(),\n\t\t\t\t\tGrammarToken.var._rule(),\n\t\t\t\t\tGrammarToken.case._rule(),\n\t\t\t\t\tGrammarToken.caseBlock._rule(),\n\t\t\t\t\tGrammarToken.func._rule(),\n\t\t\t\t\tGrammarToken.switch._rule(),\n\t\t\t\t\tGrammarToken.return._rule(),\n\t\t\t\t\tGrammarToken.alias._rule(),\n\t\t\t\t\tGrammarToken.call._rule(),\n\t\t\t\t\tGrammarToken.guard._rule(),\n\t\t\t\t\tGrammarToken.assignment._rule(),\n\t\t\t\t\t].oneOf(token: GrammarToken.statement)\n\t\t\t\t\trecursiveRule.surrogateRule = rule\n\t\t\t\t\treturn recursiveRule\n\t\t\t\t}\n\t\t\t\treturn cachedRule\n\t\t\t// swift\n\t\t\tcase .swift:\n\t\t\t\treturn [\n\t\t\t\t\t\t\t\tGrammarToken.ws._rule(),\n\t\t\t\t\t\t\t\tGrammarToken.statement._rule(),\n\t\t\t\t\t\t\t\t].oneOf(token: GrammarToken._transient).repeated(min: 0, producing: GrammarToken.swift)\n\t\t\t}\n\t\t}\n\n\t\t// Color Definitions\n\t\tfileprivate var color : NSColor? {\n\t\t\tswitch self {\n\t\t\tcase .comment:\treturn #colorLiteral(red:0.11457, green:0.506016, blue:0.128891, alpha: 1)\n\t\t\tcase .scope:\treturn #colorLiteral(red:0.207304, green:0.362127, blue:0.401488, alpha: 1)\n\t\t\tcase .number:\treturn #colorLiteral(red:0.0, green:0.589801, blue:1.0, alpha: 1)\n\t\t\tcase .string:\treturn #colorLiteral(red:0.815686, green:0.129412, blue:0.12549, alpha: 1)\n\t\t\tcase .variable:\treturn #colorLiteral(red:0.309804, green:0.541176, blue:0.6, alpha: 1)\n\t\t\tdefault:\treturn nil\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Color Dictionary\n\tstatic var colors = [\"comment\" : GrammarToken.comment.color!, \"scope\" : GrammarToken.scope.color!, \"number\" : GrammarToken.number.color!, \"string\" : GrammarToken.string.color!, \"variable\" : GrammarToken.variable.color!]\n\n\t// Cache for left-hand recursive rules\n\tprivate static var leftHandRecursiveRules = [ Int : Rule ]()\n\n\t// Initialize the parser with the base rule set\n\tinit(){\n\t\tsuper.init(grammar: [GrammarToken.swift._rule()])\n\t}\n}\n"
    
    let stlrSource = "//\n// Definition of STLR in STLR  \n//\n// STLR can be fully described itself, and this example is provided to both provide \n// a formal document capturing STLR and to illustrate a complex use of the format\n//\n// Change log: \n//\t\t\tv0.0.0\t\t8  Aug 2016 \tInitial version\n//\t\t\tv0.0.1\t\t15 Aug 2016\tAdded annotations changed to remove semi-colons and use \" not \'\n//\t\t\tv0.0.2\t\t16 Aug 2016\tAdded look ahead\n//\t\t\tv0.0.3\t\t17 Aug 2017\tAdded errors to grammar \n//\t\t\tv0.0.4\t\t18 Aug 2018\tChanged the format of annotations to be more Swift like \n\n//\n// Whitespace \n// \ncomment \t\t\t\t= \"//\" (.newlines!)* .newlines \nwhitespace\t \t\t= comment | .whitespacesAndNewlines\nows\t\t\t\t\t\t= whitespace*\n\n//\n// Constants \n//\n//definition\t\t\t= \"const\"\tows identifier ows \"=\" ows literal .whitespaces* whitespace\n\n//\n// Quantifiers\n//\nquantifier\t\t\t= \"*\" | \"+\" | \"!\" | \"-\" | \"?\" \n\n//\n// Parsing Control \n//\nlookahead\t\t\t\t= \">>\"\n\n//\n// String \n//\nstringQuote\t\t\t= \"\\\"\"\nescapedCharacters \t= stringQuote | \"r\" | \"n\" | \"t\" | \"\\\\\"\nescapedCharacter \t= \"\\\\\" escapedCharacters\nstringCharacter \t\t= escapedCharacter | stringQuote!\nterminalBody\t\t\t= @error(\"Terminals must have at least one character\")\n\t\t\t\t\t\t  stringCharacter+\nstringBody\t\t\t= stringCharacter*\nstring\t\t\t\t\t= stringQuote \n\t\t\t\t\t\t\tstringBody \n\t\t\t\t\t\t  @error(\"Missing terminating quote\")\n\t\t\t\t\t\t  stringQuote\nterminalString\t\t= stringQuote \n\t\t\t\t\t\t\tterminalBody \n\t\t\t\t\t\t  @error(\"Missing terminating quote\")\n\t\t\t\t\t\t  stringQuote\n\n//\n// Character Sets and Ranges \n//\ncharacterSetName\t\t= \"letters\" | \n\t\t\t\t\t\t  \"uppercaseLetters\" | \n\t\t\t\t\t\t  \"lowercaseLetters\" | \n\t\t\t\t\t\t  \"alphaNumerics\" | \n\t\t\t\t\t\t  \"decimalDigits\" | \n\t\t\t\t\t\t  \"whitespacesAndNewlines\" | \n\t\t\t\t\t\t  \"whitespaces\" | \n\t\t\t\t\t\t  \"newlines\"\ncharacterSet\t\t\t= \".\" characterSetName\n\nrangeOperator\t\t\t= \".\" @error(\"Expected ... in character range\")\"..\"\ncharacterRange\t\t= string rangeOperator @error(\"Range must be terminated\")string\n\n//\n// Types\n//\nnumber \t= (\"-\" | \"+\")? .decimalDigits+\nboolean \t= \"true\" | \"false\"\nliteral= string | number | boolean\n\n//\n// Annotations  \n//\nannotation  = \"@\" label ( \"(\" literal \")\" )?\nannotations = (annotation ows)+\n\ncustomLabel  = (.letters | \"_\") ( .letters | .decimalDigits | \"_\" )*\ndefinedLabel = \"id\" | \"error\" \nlabel = definedLabel | customLabel\n\n//\n// Element\n//\nterminal \t\t\t\t= characterSet | characterRange | terminalString \ngroup\t\t\t\t\t= \"(\" whitespace* \n\t\t\t\t\t\t\texpression whitespace* \n\t\t\t\t\t\t\t@error(\"Expected \')\'\") \n\t\t\t\t\t\t   \")\" \nidentifier \t\t\t= (.letters | \"_\") ( .letters | .decimalDigits | \"_\" )*  \n\nelement \t\t\t\t= annotations? lookahead? ( group | terminal | identifier ) quantifier? \n\n//\n// Expressions\n//\nor \t\t\t\t\t\t=  whitespace* \"|\" whitespace*\nthen \t\t\t\t\t= (whitespace* \"+\" whitespace*) | whitespace+\n\nchoice\t\t\t\t\t= element (or @error(\"Expected terminal, identifier, or group\")element)+\nassignmentOperators\t= \"=\" | \"+=\" | \"|=\"\nnotNewRule\t\t\t= (annotations? identifier whitespace* assignmentOperators)!\nsequence\t\t\t\t= element (then >>notNewRule @error(\"Expected terminal, identifier, or group\")element)+ \n\nexpression \t\t\t= choice | sequence | element\n\n//\n// Rule\n//\nlhs\t\t\t\t\t\t= whitespace* annotations? identifier whitespace* assignmentOperators\nrule \t\t\t\t\t= lhs whitespace* @error(\"Expected expression\")expression\n\n//\n// Grammar\n//\ngrammar\t\t\t \t\t= @error(\"Expected at least one rule\")rule+\n\n//\n// Mop up other gaps\n//\nnewline\t\t\t\t= comment | .newlines"
    
    override func setUp() {
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        super.tearDown()
    }
    
    func testPerformanceOfScanString() {
        let sourceLength = 200000
        
        var source = ""
        
        for _ in 0..<sourceLength {
            source += "Hello world"
        }
        
        var scanCount = 0
        
        // This is an example of a performance test case.
        self.measure {
            let lexer = Lexer(source: source)
            scanCount = 0
            do {
                while scanCount < sourceLength{
                    try lexer.scan(terminal: "Hello world")
                    scanCount += 1
                }
                
                
                XCTAssert(lexer.endOfInput, "Expected to be at end of input")
            } catch {
                XCTFail("Scan should not throw \(scanCount)")
            }
        }
    }
    
    
    func testPerformanceOfScanCharacterInSet() {
        let sourceLength = 1500000
        let source = String(repeating: "a", count: sourceLength)
        
        let characterSet = CharacterSet(charactersIn: "a")
        var scanCount = 0
        
        // This is an example of a performance test case.
        self.measure {
            let lexer = Lexer(source: source)
            scanCount = 0
            do {
                while scanCount < sourceLength{
                    try lexer.scan(oneOf: characterSet)
                    scanCount += 1
                }
                
                
                XCTAssert(lexer.endOfInput, "Expected to be at end of input")
            } catch {
                XCTFail("Scan should not throw \(scanCount)")
            }
        }
    }

    func testPerformanceSTLR() {
        
        let _ = STLRParser(source: stlrSource)
        
        // This is an example of a performance test case.
        self.measure {
            let stlr = STLRParser(source: self.stlrSource)
            
            let ruleCount = stlr.ast.rules.count
            XCTAssert(ruleCount == 40,"Got \(ruleCount) rules")
            
            do {
                print(stlr.ast.errors)
                try stlr.ast.validate()
            } catch (let error){
                XCTFail("Did not validate \(error)")
            }
        }
    }
    
    func testSwiftParserPerformance(){
        final class NullIR : IntermediateRepresentation{
            fileprivate func willBuildFrom(source: String, with: Language) {
                
            }
            
            fileprivate func didBuild() {
                
            }
            
            fileprivate func didEvaluate(rule: Rule, matchResult: MatchResult) {
                
            }
            
            fileprivate func willEvaluate(rule: Rule, at position: String.UnicodeScalarView.Index) -> MatchResult? {
                return nil
            }
            
            func resetState() {
                
            }
        }
        
        let parser = SwiftParser()
        let _ = parser.build(source: swiftSource) as NullIR
        
        // This is an example of a performance test case.
        self.measure {
            let _ = parser.build(source: self.swiftSource) as NullIR
        }
        
    }
    
    func testPerformanceSTLRParseOnly() {
        final class NullIR : IntermediateRepresentation{
            fileprivate func willBuildFrom(source: String, with: Language) {
                
            }
            
            fileprivate func didBuild() {
                
            }
            
            fileprivate func didEvaluate(rule: Rule, matchResult: MatchResult) {
                
            }
            
            fileprivate func willEvaluate(rule: Rule, at position: String.UnicodeScalarView.Index) -> MatchResult? {
                return nil
            }
            
            func resetState() {
                
            }
        }
        let parser = STLRParser(source: stlrSource)
        
        // This is an example of a performance test case.
        self.measure {
            do {
                let result = try parser.grammar[0].match(with: Lexer(source:self.stlrSource), for: NullIR())
                if case .success = result {
                    
                } else {
                    XCTFail("Failed to parse")
                }
            } catch (let error){
                XCTFail("Unexpected failure \(error)")
            }
        }
    }
}
